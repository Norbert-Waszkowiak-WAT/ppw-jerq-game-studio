//-----------------------------------------------------------------------------
// <auto-generated>
//     This file was generated by the C# SDK Code Generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------------


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using UnityEngine;
using UnityEngine.Networking;
using UnityEngine.Scripting;
using Unity.Services.Lobbies.Models;
using Unity.Services.Lobbies.Scheduler;
using Unity.Services.Authentication.Internal;

namespace Unity.Services.Lobbies.Lobby
{
    internal static class JsonSerialization
    {
        public static byte[] Serialize<T>(T obj)
        {
            return Encoding.UTF8.GetBytes(SerializeToString(obj));
        }

        public static string SerializeToString<T>(T obj)
        {
            return JsonConvert.SerializeObject(obj, new JsonSerializerSettings{ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore});
        }
    }

    /// <summary>
    /// LobbyApiBaseRequest class
    /// </summary>
    [Preserve]
    internal class LobbyApiBaseRequest
    {
        /// <summary>
        /// Helper function to add a provided key and value to the provided
        /// query params and to escape the values correctly if it is a URL.
        /// </summary>
        /// <param name="queryParams">A `List/<string/>` of the query parameters.</param>
        /// <param name="key">The key to be added.</param>
        /// <param name="value">The value to be added.</param>
        /// <returns>Returns a `List/<string/>` with the `key` and `value` added to the provided `queryParams`.</returns>
        [Preserve]
        public List<string> AddParamsToQueryParams(List<string> queryParams, string key, string value)
        {
            key = UnityWebRequest.EscapeURL(key);
            value = UnityWebRequest.EscapeURL(value);
            queryParams.Add($"{key}={value}");

            return queryParams;
        }

        /// <summary>
        /// Helper function to add a provided key and list of values to the
        /// provided query params and to escape the values correctly if it is a
        /// URL.
        /// </summary>
        /// <param name="queryParams">A `List/<string/>` of the query parameters.</param>
        /// <param name="key">The key to be added.</param>
        /// <param name="values">List of values to be added.</param>
        /// <param name="style">string for defining the style, currently unused.</param>
        /// <param name="explode">True if query params should be escaped and added separately.</param>
        /// <returns>Returns a `List/<string/>`</returns>
        [Preserve]
        public List<string> AddParamsToQueryParams(List<string> queryParams, string key, List<string> values, string style, bool explode)
        {
            if (explode)
            {
                foreach(var value in values)
                {
                    string escapedValue = UnityWebRequest.EscapeURL(value);
                    queryParams.Add($"{UnityWebRequest.EscapeURL(key)}={escapedValue}");
                }
            }
            else
            {
                string paramString = $"{UnityWebRequest.EscapeURL(key)}=";
                foreach(var value in values)
                {
                    paramString += UnityWebRequest.EscapeURL(value) + ",";
                }
                paramString = paramString.Remove(paramString.Length - 1);
                queryParams.Add(paramString);
            }

            return queryParams;
        }

        /// <summary>
        /// Helper function to add a provided map of keys and values, representing a model, to the
        /// provided query params.
        /// </summary>
        /// <param name="queryParams">A `List/<string/>` of the query parameters.</param>
        /// <param name="modelVars">A `Dictionary` representing the vars of the model</param>
        /// <returns>Returns a `List/<string/>`</returns>
        [Preserve]
        public List<string> AddParamsToQueryParams(List<string> queryParams, Dictionary<string, string> modelVars)
        {
            foreach(var key in modelVars.Keys)
            {
                string escapedValue = UnityWebRequest.EscapeURL(modelVars[key]);
                queryParams.Add($"{UnityWebRequest.EscapeURL(key)}={escapedValue}");
            }

            return queryParams;
        }

        /// <summary>
        /// Helper function to add a provided key and value to the provided
        /// query params and to escape the values correctly if it is a URL.
        /// </summary>
        /// <param name="queryParams">A `List/<string/>` of the query parameters.</param>
        /// <param name="key">The key to be added.</param>
        /// <typeparam name="T">The type of the value to be added.</typeparam>
        /// <param name="value">The value to be added.</param>
        /// <returns>Returns a `List/<string/>`</returns>
        [Preserve]
        public List<string> AddParamsToQueryParams<T>(List<string> queryParams, string key, T value)
        {
            if (queryParams == null)
            {
                queryParams = new List<string>();
            }

            key = UnityWebRequest.EscapeURL(key);
            string valueString = UnityWebRequest.EscapeURL(value.ToString());
            queryParams.Add($"{key}={valueString}");
            return queryParams;
        }

        /// <summary>
        /// Constructs a string representing an array path parameter.
        /// </summary>
        /// <param name="pathParam">The list of values to convert to string.</param>
        /// <returns>String representing the param.</returns>
        [Preserve]
        public string GetPathParamString(List<string> pathParam)
        {
            string paramString = "";
            foreach(var value in pathParam)
            {
                paramString += UnityWebRequest.EscapeURL(value) + ",";
            }
            paramString = paramString.Remove(paramString.Length - 1);
            return paramString;
        }

        /// <summary>
        /// Constructs the body of the request based on IO stream.
        /// </summary>
        /// <param name="stream">The IO stream to use.</param>
        /// <returns>Byte array representing the body.</returns>
        public byte[] ConstructBody(System.IO.Stream stream)
        {
            if (stream != null)
            {
                using (System.IO.MemoryStream ms = new System.IO.MemoryStream())
                {
                    stream.CopyTo(ms);
                    return ms.ToArray();
                }
            }
            return null;
        }

        /// <summary>
        /// Construct the request body based on string value.
        /// </summary>
        /// <param name="s">The input body.</param>
        /// <returns>Byte array representing the body.</returns>
        public byte[] ConstructBody(string s)
        {
            return System.Text.Encoding.UTF8.GetBytes(s);
        }

        /// <summary>
        /// Construct request body based on generic object.
        /// </summary>
        /// <param name="o">The object to use.</param>
        /// <returns>Byte array representing the body.</returns>
        public byte[] ConstructBody(object o)
        {
            return JsonSerialization.Serialize(o);
        }

        /// <summary>
        /// Generate an accept header.
        /// </summary>
        /// <param name="accepts">list of accepts objects.</param>
        /// <returns>The generated accept header.</returns>
        public string GenerateAcceptHeader(string[] accepts)
        {
            if (accepts.Length == 0)
            {
                return null;
            }
            for (int i = 0; i < accepts.Length; ++i)
            {
                if (string.Equals(accepts[i], "application/json", System.StringComparison.OrdinalIgnoreCase))
                {
                    return "application/json";
                }
            }
            return string.Join(", ", accepts);
        }

        private static readonly Regex JsonRegex = new Regex(@"application\/json(;\s)?((charset=utf8|q=[0-1]\.\d)(\s)?)*");

        /// <summary>
        /// Generate Content Type Header.
        /// </summary>
        /// <param name="contentTypes">The content types.</param>
        /// <returns>The Content Type Header.</returns>
        public string GenerateContentTypeHeader(string[] contentTypes)
        {
            if (contentTypes.Length == 0)
            {
                return null;
            }

            for(int i = 0; i < contentTypes.Length; ++i)
            {
                if (!string.IsNullOrWhiteSpace(contentTypes[i]) && JsonRegex.IsMatch(contentTypes[i]))
                {
                    return contentTypes[i];
                }
            }
            return contentTypes[0];
        }

        /// <summary>
        /// Generate multipart form file section.
        /// </summary>
        /// <param name="paramName">The parameter name.</param>
        /// <param name="stream">The file stream to use.</param>
        /// <param name="contentType">The content type.</param>
        /// <returns>Returns a multipart form section.</returns>
        public IMultipartFormSection GenerateMultipartFormFileSection(string paramName, System.IO.FileStream stream, string contentType)
        {
            return new MultipartFormFileSection(paramName, ConstructBody(stream), GetFileName(stream.Name), contentType);
        }

        /// <summary>
        /// Generate multipart form file section.
        /// </summary>
        /// <param name="paramName">The parameter name.</param>
        /// <param name="stream">The IO stream to use.</param>
        /// <param name="contentType">The content type.</param>
        /// <returns>Returns a multipart form section.</returns>
        public IMultipartFormSection GenerateMultipartFormFileSection(string paramName, System.IO.Stream stream, string contentType)
        {
            return new MultipartFormFileSection(paramName, ConstructBody(stream), Guid.NewGuid().ToString(), contentType);
        }

        private string GetFileName(string filePath)
        {
            return System.IO.Path.GetFileName(filePath);
        }
    }

    /// <summary>
    /// BulkUpdateLobbyRequest
    /// Bulk update
    /// </summary>
    [Preserve]
    internal class BulkUpdateLobbyRequest : LobbyApiBaseRequest
    {
        /// <summary>Accessor for lobbyId </summary>
        [Preserve]
        public string LobbyId { get; }
        /// <summary>Accessor for serviceId </summary>
        [Preserve]
        public string ServiceId { get; }
        /// <summary>Accessor for impersonatedUserId </summary>
        [Preserve]
        public string ImpersonatedUserId { get; }
        /// <summary>Accessor for bulkUpdateRequest </summary>
        [Preserve]
        public Unity.Services.Lobbies.Models.BulkUpdateRequest BulkUpdateRequest { get; }
        string PathAndQueryParams;

        /// <summary>
        /// BulkUpdateLobby Request Object.
        /// Bulk update
        /// </summary>
        /// <param name="lobbyId">The ID of the lobby to execute the request against. It should be composed of 64 characters or less, and only have dashes, underscores and alphanumeric characters.</param>
        /// <param name="serviceId">When service authentication is used, this provides a logical identity for the service</param>
        /// <param name="impersonatedUserId">When service authentication is used, this provides a 'playerId' to execute as. If this header is detected, the service request will be identical to a request from the specified player.</param>
        /// <param name="bulkUpdateRequest">BulkUpdateRequest param</param>
        [Preserve]
        public BulkUpdateLobbyRequest(string lobbyId, string serviceId = default(string), string impersonatedUserId = default(string), Unity.Services.Lobbies.Models.BulkUpdateRequest bulkUpdateRequest = default(Unity.Services.Lobbies.Models.BulkUpdateRequest))
        {
            LobbyId = lobbyId;

            ServiceId = serviceId;
            ImpersonatedUserId = impersonatedUserId;
            BulkUpdateRequest = bulkUpdateRequest;
            PathAndQueryParams = $"/{lobbyId}/bulkupdate";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            if(BulkUpdateRequest != null)
            {
                return ConstructBody(BulkUpdateRequest);
            }
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json"
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "POST";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }

            if(!string.IsNullOrEmpty(ServiceId))
            {
                headers.Add("Service-id", ServiceId);
            }
            if(!string.IsNullOrEmpty(ImpersonatedUserId))
            {
                headers.Add("Impersonated-user-id", ImpersonatedUserId);
            }

            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// CreateLobbyRequest
    /// Create a lobby
    /// </summary>
    [Preserve]
    internal class CreateLobbyRequest : LobbyApiBaseRequest
    {
        /// <summary>Accessor for serviceId </summary>
        [Preserve]
        public string ServiceId { get; }
        /// <summary>Accessor for impersonatedUserId </summary>
        [Preserve]
        public string ImpersonatedUserId { get; }
        /// <summary>Accessor for createRequest </summary>
        [Preserve]
        public Unity.Services.Lobbies.Models.CreateRequest CreateRequest { get; }
        string PathAndQueryParams;

        /// <summary>
        /// CreateLobby Request Object.
        /// Create a lobby
        /// </summary>
        /// <param name="serviceId">When service authentication is used, this provides a logical identity for the service</param>
        /// <param name="impersonatedUserId">When service authentication is used, this provides a 'playerId' to execute as. If this header is detected, the service request will be identical to a request from the specified player.</param>
        /// <param name="createRequest">CreateRequest param</param>
        [Preserve]
        public CreateLobbyRequest(string serviceId = default(string), string impersonatedUserId = default(string), Unity.Services.Lobbies.Models.CreateRequest createRequest = default(Unity.Services.Lobbies.Models.CreateRequest))
        {
            ServiceId = serviceId;
            ImpersonatedUserId = impersonatedUserId;
            CreateRequest = createRequest;
            PathAndQueryParams = $"/create";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            if(CreateRequest != null)
            {
                return ConstructBody(CreateRequest);
            }
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json"
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "POST";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }

            if(!string.IsNullOrEmpty(ServiceId))
            {
                headers.Add("Service-id", ServiceId);
            }
            if(!string.IsNullOrEmpty(ImpersonatedUserId))
            {
                headers.Add("Impersonated-user-id", ImpersonatedUserId);
            }

            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// CreateOrJoinLobbyRequest
    /// Create or join a lobby with lobby ID
    /// </summary>
    [Preserve]
    internal class CreateOrJoinLobbyRequest : LobbyApiBaseRequest
    {
        /// <summary>Accessor for lobbyId </summary>
        [Preserve]
        public string LobbyId { get; }
        /// <summary>Accessor for serviceId </summary>
        [Preserve]
        public string ServiceId { get; }
        /// <summary>Accessor for impersonatedUserId </summary>
        [Preserve]
        public string ImpersonatedUserId { get; }
        /// <summary>Accessor for createRequest </summary>
        [Preserve]
        public Unity.Services.Lobbies.Models.CreateRequest CreateRequest { get; }
        string PathAndQueryParams;

        /// <summary>
        /// CreateOrJoinLobby Request Object.
        /// Create or join a lobby with lobby ID
        /// </summary>
        /// <param name="lobbyId">The ID of the lobby to execute the request against. It should be composed of 64 characters or less, and only have dashes, underscores and alphanumeric characters.</param>
        /// <param name="serviceId">When service authentication is used, this provides a logical identity for the service</param>
        /// <param name="impersonatedUserId">When service authentication is used, this provides a 'playerId' to execute as. If this header is detected, the service request will be identical to a request from the specified player.</param>
        /// <param name="createRequest">CreateRequest param</param>
        [Preserve]
        public CreateOrJoinLobbyRequest(string lobbyId, string serviceId = default(string), string impersonatedUserId = default(string), Unity.Services.Lobbies.Models.CreateRequest createRequest = default(Unity.Services.Lobbies.Models.CreateRequest))
        {
            LobbyId = lobbyId;

            ServiceId = serviceId;
            ImpersonatedUserId = impersonatedUserId;
            CreateRequest = createRequest;
            PathAndQueryParams = $"/{lobbyId}/createorjoin";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            if(CreateRequest != null)
            {
                return ConstructBody(CreateRequest);
            }
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json"
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "POST";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }

            if(!string.IsNullOrEmpty(ServiceId))
            {
                headers.Add("Service-id", ServiceId);
            }
            if(!string.IsNullOrEmpty(ImpersonatedUserId))
            {
                headers.Add("Impersonated-user-id", ImpersonatedUserId);
            }

            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// DeleteLobbyRequest
    /// Delete a lobby
    /// </summary>
    [Preserve]
    internal class DeleteLobbyRequest : LobbyApiBaseRequest
    {
        /// <summary>Accessor for lobbyId </summary>
        [Preserve]
        public string LobbyId { get; }
        /// <summary>Accessor for serviceId </summary>
        [Preserve]
        public string ServiceId { get; }
        /// <summary>Accessor for impersonatedUserId </summary>
        [Preserve]
        public string ImpersonatedUserId { get; }
        string PathAndQueryParams;

        /// <summary>
        /// DeleteLobby Request Object.
        /// Delete a lobby
        /// </summary>
        /// <param name="lobbyId">The ID of the lobby to execute the request against. It should be composed of 64 characters or less, and only have dashes, underscores and alphanumeric characters.</param>
        /// <param name="serviceId">When service authentication is used, this provides a logical identity for the service</param>
        /// <param name="impersonatedUserId">When service authentication is used, this provides a 'playerId' to execute as. If this header is detected, the service request will be identical to a request from the specified player.</param>
        [Preserve]
        public DeleteLobbyRequest(string lobbyId, string serviceId = default(string), string impersonatedUserId = default(string))
        {
            LobbyId = lobbyId;

            ServiceId = serviceId;
            ImpersonatedUserId = impersonatedUserId;
            PathAndQueryParams = $"/{lobbyId}";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "DELETE";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }

            if(!string.IsNullOrEmpty(ServiceId))
            {
                headers.Add("Service-id", ServiceId);
            }
            if(!string.IsNullOrEmpty(ImpersonatedUserId))
            {
                headers.Add("Impersonated-user-id", ImpersonatedUserId);
            }

            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetHostedLobbiesRequest
    /// Get a player/service&#39;s hosted lobbies
    /// </summary>
    [Preserve]
    internal class GetHostedLobbiesRequest : LobbyApiBaseRequest
    {
        /// <summary>Accessor for serviceId </summary>
        [Preserve]
        public string ServiceId { get; }
        /// <summary>Accessor for impersonatedUserId </summary>
        [Preserve]
        public string ImpersonatedUserId { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetHostedLobbies Request Object.
        /// Get a player/service&#39;s hosted lobbies
        /// </summary>
        /// <param name="serviceId">When service authentication is used, this provides a logical identity for the service</param>
        /// <param name="impersonatedUserId">When service authentication is used, this provides a 'playerId' to execute as. If this header is detected, the service request will be identical to a request from the specified player.</param>
        [Preserve]
        public GetHostedLobbiesRequest(string serviceId = default(string), string impersonatedUserId = default(string))
        {
            ServiceId = serviceId;
            ImpersonatedUserId = impersonatedUserId;
            PathAndQueryParams = $"/hosted";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }

            if(!string.IsNullOrEmpty(ServiceId))
            {
                headers.Add("Service-id", ServiceId);
            }
            if(!string.IsNullOrEmpty(ImpersonatedUserId))
            {
                headers.Add("Impersonated-user-id", ImpersonatedUserId);
            }

            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetJoinedLobbiesRequest
    /// Get a player&#39;s joined lobbies
    /// </summary>
    [Preserve]
    internal class GetJoinedLobbiesRequest : LobbyApiBaseRequest
    {
        /// <summary>Accessor for serviceId </summary>
        [Preserve]
        public string ServiceId { get; }
        /// <summary>Accessor for impersonatedUserId </summary>
        [Preserve]
        public string ImpersonatedUserId { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetJoinedLobbies Request Object.
        /// Get a player&#39;s joined lobbies
        /// </summary>
        /// <param name="serviceId">When service authentication is used, this provides a logical identity for the service</param>
        /// <param name="impersonatedUserId">When service authentication is used, this provides a 'playerId' to execute as. If this header is detected, the service request will be identical to a request from the specified player.</param>
        [Preserve]
        public GetJoinedLobbiesRequest(string serviceId = default(string), string impersonatedUserId = default(string))
        {
            ServiceId = serviceId;
            ImpersonatedUserId = impersonatedUserId;
            PathAndQueryParams = $"/joined";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }

            if(!string.IsNullOrEmpty(ServiceId))
            {
                headers.Add("Service-id", ServiceId);
            }
            if(!string.IsNullOrEmpty(ImpersonatedUserId))
            {
                headers.Add("Impersonated-user-id", ImpersonatedUserId);
            }

            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetLobbyRequest
    /// Get lobby details
    /// </summary>
    [Preserve]
    internal class GetLobbyRequest : LobbyApiBaseRequest
    {
        /// <summary>Accessor for lobbyId </summary>
        [Preserve]
        public string LobbyId { get; }
        /// <summary>Accessor for serviceId </summary>
        [Preserve]
        public string ServiceId { get; }
        /// <summary>Accessor for impersonatedUserId </summary>
        [Preserve]
        public string ImpersonatedUserId { get; }
        /// <summary>Accessor for ifNoneMatch </summary>
        [Preserve]
        public string IfNoneMatch { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetLobby Request Object.
        /// Get lobby details
        /// </summary>
        /// <param name="lobbyId">The ID of the lobby to execute the request against. It should be composed of 64 characters or less, and only have dashes, underscores and alphanumeric characters.</param>
        /// <param name="serviceId">When service authentication is used, this provides a logical identity for the service</param>
        /// <param name="impersonatedUserId">When service authentication is used, this provides a 'playerId' to execute as. If this header is detected, the service request will be identical to a request from the specified player.</param>
        /// <param name="ifNoneMatch">The etag of the record being requested. Results/actions are only returned/executed when the current record version does not match the provided value.</param>
        [Preserve]
        public GetLobbyRequest(string lobbyId, string serviceId = default(string), string impersonatedUserId = default(string), string ifNoneMatch = default(string))
        {
            LobbyId = lobbyId;

            ServiceId = serviceId;
            ImpersonatedUserId = impersonatedUserId;
            IfNoneMatch = ifNoneMatch;
            PathAndQueryParams = $"/{lobbyId}";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }

            if(!string.IsNullOrEmpty(ServiceId))
            {
                headers.Add("Service-id", ServiceId);
            }
            if(!string.IsNullOrEmpty(ImpersonatedUserId))
            {
                headers.Add("Impersonated-user-id", ImpersonatedUserId);
            }
            if(!string.IsNullOrEmpty(IfNoneMatch))
            {
                headers.Add("If-none-match", IfNoneMatch);
            }

            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// HeartbeatRequest
    /// Heartbeat a lobby
    /// </summary>
    [Preserve]
    internal class HeartbeatRequest : LobbyApiBaseRequest
    {
        /// <summary>Accessor for lobbyId </summary>
        [Preserve]
        public string LobbyId { get; }
        /// <summary>Accessor for serviceId </summary>
        [Preserve]
        public string ServiceId { get; }
        /// <summary>Accessor for impersonatedUserId </summary>
        [Preserve]
        public string ImpersonatedUserId { get; }
        /// <summary>Accessor for body </summary>
        [Preserve]
        public object Body { get; }
        string PathAndQueryParams;

        /// <summary>
        /// Heartbeat Request Object.
        /// Heartbeat a lobby
        /// </summary>
        /// <param name="lobbyId">The ID of the lobby to execute the request against. It should be composed of 64 characters or less, and only have dashes, underscores and alphanumeric characters.</param>
        /// <param name="serviceId">When service authentication is used, this provides a logical identity for the service</param>
        /// <param name="impersonatedUserId">When service authentication is used, this provides a 'playerId' to execute as. If this header is detected, the service request will be identical to a request from the specified player.</param>
        /// <param name="body">body param</param>
        [Preserve]
        public HeartbeatRequest(string lobbyId, string serviceId = default(string), string impersonatedUserId = default(string), object body = default(object))
        {
            LobbyId = lobbyId;

            ServiceId = serviceId;
            ImpersonatedUserId = impersonatedUserId;
            Body = body;
            PathAndQueryParams = $"/{lobbyId}/heartbeat";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            if(Body != null)
            {
                return ConstructBody(Body);
            }
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json"
            };

            string[] accepts = {
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "POST";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }

            if(!string.IsNullOrEmpty(ServiceId))
            {
                headers.Add("Service-id", ServiceId);
            }
            if(!string.IsNullOrEmpty(ImpersonatedUserId))
            {
                headers.Add("Impersonated-user-id", ImpersonatedUserId);
            }

            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// JoinLobbyByCodeRequest
    /// Join a lobby with lobby code
    /// </summary>
    [Preserve]
    internal class JoinLobbyByCodeRequest : LobbyApiBaseRequest
    {
        /// <summary>Accessor for serviceId </summary>
        [Preserve]
        public string ServiceId { get; }
        /// <summary>Accessor for impersonatedUserId </summary>
        [Preserve]
        public string ImpersonatedUserId { get; }
        /// <summary>Accessor for joinByCodeRequest </summary>
        [Preserve]
        public Unity.Services.Lobbies.Models.JoinByCodeRequest JoinByCodeRequest { get; }
        string PathAndQueryParams;

        /// <summary>
        /// JoinLobbyByCode Request Object.
        /// Join a lobby with lobby code
        /// </summary>
        /// <param name="serviceId">When service authentication is used, this provides a logical identity for the service</param>
        /// <param name="impersonatedUserId">When service authentication is used, this provides a 'playerId' to execute as. If this header is detected, the service request will be identical to a request from the specified player.</param>
        /// <param name="joinByCodeRequest">JoinByCodeRequest param</param>
        [Preserve]
        public JoinLobbyByCodeRequest(string serviceId = default(string), string impersonatedUserId = default(string), Unity.Services.Lobbies.Models.JoinByCodeRequest joinByCodeRequest = default(Unity.Services.Lobbies.Models.JoinByCodeRequest))
        {
            ServiceId = serviceId;
            ImpersonatedUserId = impersonatedUserId;
            JoinByCodeRequest = joinByCodeRequest;
            PathAndQueryParams = $"/joinbycode";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            if(JoinByCodeRequest != null)
            {
                return ConstructBody(JoinByCodeRequest);
            }
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json"
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "POST";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }

            if(!string.IsNullOrEmpty(ServiceId))
            {
                headers.Add("Service-id", ServiceId);
            }
            if(!string.IsNullOrEmpty(ImpersonatedUserId))
            {
                headers.Add("Impersonated-user-id", ImpersonatedUserId);
            }

            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// JoinLobbyByIdRequest
    /// Join a lobby with lobby ID
    /// </summary>
    [Preserve]
    internal class JoinLobbyByIdRequest : LobbyApiBaseRequest
    {
        /// <summary>Accessor for lobbyId </summary>
        [Preserve]
        public string LobbyId { get; }
        /// <summary>Accessor for serviceId </summary>
        [Preserve]
        public string ServiceId { get; }
        /// <summary>Accessor for impersonatedUserId </summary>
        [Preserve]
        public string ImpersonatedUserId { get; }
        /// <summary>Accessor for joinByIdRequest </summary>
        [Preserve]
        public Unity.Services.Lobbies.Models.JoinByIdRequest JoinByIdRequest { get; }
        string PathAndQueryParams;

        /// <summary>
        /// JoinLobbyById Request Object.
        /// Join a lobby with lobby ID
        /// </summary>
        /// <param name="lobbyId">The ID of the lobby to execute the request against. It should be composed of 64 characters or less, and only have dashes, underscores and alphanumeric characters.</param>
        /// <param name="serviceId">When service authentication is used, this provides a logical identity for the service</param>
        /// <param name="impersonatedUserId">When service authentication is used, this provides a 'playerId' to execute as. If this header is detected, the service request will be identical to a request from the specified player.</param>
        /// <param name="joinByIdRequest">JoinByIdRequest param</param>
        [Preserve]
        public JoinLobbyByIdRequest(string lobbyId, string serviceId = default(string), string impersonatedUserId = default(string), Unity.Services.Lobbies.Models.JoinByIdRequest joinByIdRequest = default(Unity.Services.Lobbies.Models.JoinByIdRequest))
        {
            LobbyId = lobbyId;

            ServiceId = serviceId;
            ImpersonatedUserId = impersonatedUserId;
            JoinByIdRequest = joinByIdRequest;
            PathAndQueryParams = $"/{lobbyId}/join";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            if(JoinByIdRequest != null)
            {
                return ConstructBody(JoinByIdRequest);
            }
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json"
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "POST";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }

            if(!string.IsNullOrEmpty(ServiceId))
            {
                headers.Add("Service-id", ServiceId);
            }
            if(!string.IsNullOrEmpty(ImpersonatedUserId))
            {
                headers.Add("Impersonated-user-id", ImpersonatedUserId);
            }

            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// QueryLobbiesRequest
    /// Query public lobbies
    /// </summary>
    [Preserve]
    internal class QueryLobbiesRequest : LobbyApiBaseRequest
    {
        /// <summary>Accessor for serviceId </summary>
        [Preserve]
        public string ServiceId { get; }
        /// <summary>Accessor for impersonatedUserId </summary>
        [Preserve]
        public string ImpersonatedUserId { get; }
        /// <summary>Accessor for queryRequest </summary>
        [Preserve]
        public Unity.Services.Lobbies.Models.QueryRequest QueryRequest { get; }
        string PathAndQueryParams;

        /// <summary>
        /// QueryLobbies Request Object.
        /// Query public lobbies
        /// </summary>
        /// <param name="serviceId">When service authentication is used, this provides a logical identity for the service</param>
        /// <param name="impersonatedUserId">When service authentication is used, this provides a 'playerId' to execute as. If this header is detected, the service request will be identical to a request from the specified player.</param>
        /// <param name="queryRequest">QueryRequest param</param>
        [Preserve]
        public QueryLobbiesRequest(string serviceId = default(string), string impersonatedUserId = default(string), Unity.Services.Lobbies.Models.QueryRequest queryRequest = default(Unity.Services.Lobbies.Models.QueryRequest))
        {
            ServiceId = serviceId;
            ImpersonatedUserId = impersonatedUserId;
            QueryRequest = queryRequest;
            PathAndQueryParams = $"/query";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            if(QueryRequest != null)
            {
                return ConstructBody(QueryRequest);
            }
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json"
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "POST";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }

            if(!string.IsNullOrEmpty(ServiceId))
            {
                headers.Add("Service-id", ServiceId);
            }
            if(!string.IsNullOrEmpty(ImpersonatedUserId))
            {
                headers.Add("Impersonated-user-id", ImpersonatedUserId);
            }

            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// QuickJoinLobbyRequest
    /// Query available lobbies and join a random one
    /// </summary>
    [Preserve]
    internal class QuickJoinLobbyRequest : LobbyApiBaseRequest
    {
        /// <summary>Accessor for serviceId </summary>
        [Preserve]
        public string ServiceId { get; }
        /// <summary>Accessor for impersonatedUserId </summary>
        [Preserve]
        public string ImpersonatedUserId { get; }
        /// <summary>Accessor for quickJoinRequest </summary>
        [Preserve]
        public Unity.Services.Lobbies.Models.QuickJoinRequest QuickJoinRequest { get; }
        string PathAndQueryParams;

        /// <summary>
        /// QuickJoinLobby Request Object.
        /// Query available lobbies and join a random one
        /// </summary>
        /// <param name="serviceId">When service authentication is used, this provides a logical identity for the service</param>
        /// <param name="impersonatedUserId">When service authentication is used, this provides a 'playerId' to execute as. If this header is detected, the service request will be identical to a request from the specified player.</param>
        /// <param name="quickJoinRequest">QuickJoinRequest param</param>
        [Preserve]
        public QuickJoinLobbyRequest(string serviceId = default(string), string impersonatedUserId = default(string), Unity.Services.Lobbies.Models.QuickJoinRequest quickJoinRequest = default(Unity.Services.Lobbies.Models.QuickJoinRequest))
        {
            ServiceId = serviceId;
            ImpersonatedUserId = impersonatedUserId;
            QuickJoinRequest = quickJoinRequest;
            PathAndQueryParams = $"/quickjoin";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            if(QuickJoinRequest != null)
            {
                return ConstructBody(QuickJoinRequest);
            }
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json"
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "POST";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }

            if(!string.IsNullOrEmpty(ServiceId))
            {
                headers.Add("Service-id", ServiceId);
            }
            if(!string.IsNullOrEmpty(ImpersonatedUserId))
            {
                headers.Add("Impersonated-user-id", ImpersonatedUserId);
            }

            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// ReconnectRequest
    /// Reconnect to a lobby after disconnecting
    /// </summary>
    [Preserve]
    internal class ReconnectRequest : LobbyApiBaseRequest
    {
        /// <summary>Accessor for lobbyId </summary>
        [Preserve]
        public string LobbyId { get; }
        /// <summary>Accessor for serviceId </summary>
        [Preserve]
        public string ServiceId { get; }
        /// <summary>Accessor for impersonatedUserId </summary>
        [Preserve]
        public string ImpersonatedUserId { get; }
        /// <summary>Accessor for body </summary>
        [Preserve]
        public object Body { get; }
        string PathAndQueryParams;

        /// <summary>
        /// Reconnect Request Object.
        /// Reconnect to a lobby after disconnecting
        /// </summary>
        /// <param name="lobbyId">The ID of the lobby to execute the request against. It should be composed of 64 characters or less, and only have dashes, underscores and alphanumeric characters.</param>
        /// <param name="serviceId">When service authentication is used, this provides a logical identity for the service</param>
        /// <param name="impersonatedUserId">When service authentication is used, this provides a 'playerId' to execute as. If this header is detected, the service request will be identical to a request from the specified player.</param>
        /// <param name="body">body param</param>
        [Preserve]
        public ReconnectRequest(string lobbyId, string serviceId = default(string), string impersonatedUserId = default(string), object body = default(object))
        {
            LobbyId = lobbyId;

            ServiceId = serviceId;
            ImpersonatedUserId = impersonatedUserId;
            Body = body;
            PathAndQueryParams = $"/{lobbyId}/reconnect";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            if(Body != null)
            {
                return ConstructBody(Body);
            }
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json"
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "POST";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }

            if(!string.IsNullOrEmpty(ServiceId))
            {
                headers.Add("Service-id", ServiceId);
            }
            if(!string.IsNullOrEmpty(ImpersonatedUserId))
            {
                headers.Add("Impersonated-user-id", ImpersonatedUserId);
            }

            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// RemovePlayerRequest
    /// Remove a player
    /// </summary>
    [Preserve]
    internal class RemovePlayerRequest : LobbyApiBaseRequest
    {
        /// <summary>Accessor for lobbyId </summary>
        [Preserve]
        public string LobbyId { get; }
        /// <summary>Accessor for playerId </summary>
        [Preserve]
        public string PlayerId { get; }
        /// <summary>Accessor for serviceId </summary>
        [Preserve]
        public string ServiceId { get; }
        /// <summary>Accessor for impersonatedUserId </summary>
        [Preserve]
        public string ImpersonatedUserId { get; }
        string PathAndQueryParams;

        /// <summary>
        /// RemovePlayer Request Object.
        /// Remove a player
        /// </summary>
        /// <param name="lobbyId">The ID of the lobby to execute the request against. It should be composed of 64 characters or less, and only have dashes, underscores and alphanumeric characters.</param>
        /// <param name="playerId">The ID of the player to execute the request against.</param>
        /// <param name="serviceId">When service authentication is used, this provides a logical identity for the service</param>
        /// <param name="impersonatedUserId">When service authentication is used, this provides a 'playerId' to execute as. If this header is detected, the service request will be identical to a request from the specified player.</param>
        [Preserve]
        public RemovePlayerRequest(string lobbyId, string playerId, string serviceId = default(string), string impersonatedUserId = default(string))
        {
            LobbyId = lobbyId;

            PlayerId = playerId;

            ServiceId = serviceId;
            ImpersonatedUserId = impersonatedUserId;
            PathAndQueryParams = $"/{lobbyId}/players/{playerId}";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "DELETE";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }

            if(!string.IsNullOrEmpty(ServiceId))
            {
                headers.Add("Service-id", ServiceId);
            }
            if(!string.IsNullOrEmpty(ImpersonatedUserId))
            {
                headers.Add("Impersonated-user-id", ImpersonatedUserId);
            }

            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// RequestTokensRequest
    /// Authentication token request
    /// </summary>
    [Preserve]
    internal class RequestTokensRequest : LobbyApiBaseRequest
    {
        /// <summary>Accessor for lobbyId </summary>
        [Preserve]
        public string LobbyId { get; }
        /// <summary>Accessor for tokenRequest </summary>
        [Preserve]
        public List<TokenRequest> TokenRequest { get; }
        /// <summary>Accessor for serviceId </summary>
        [Preserve]
        public string ServiceId { get; }
        /// <summary>Accessor for impersonatedUserId </summary>
        [Preserve]
        public string ImpersonatedUserId { get; }
        string PathAndQueryParams;

        /// <summary>
        /// RequestTokens Request Object.
        /// Authentication token request
        /// </summary>
        /// <param name="lobbyId">The ID of the lobby to execute the request against. It should be composed of 64 characters or less, and only have dashes, underscores and alphanumeric characters.</param>
        /// <param name="tokenRequest">TokenRequest param</param>
        /// <param name="serviceId">When service authentication is used, this provides a logical identity for the service</param>
        /// <param name="impersonatedUserId">When service authentication is used, this provides a 'playerId' to execute as. If this header is detected, the service request will be identical to a request from the specified player.</param>
        [Preserve]
        public RequestTokensRequest(string lobbyId, List<TokenRequest> tokenRequest, string serviceId = default(string), string impersonatedUserId = default(string))
        {
            LobbyId = lobbyId;

            TokenRequest = tokenRequest;
            ServiceId = serviceId;
            ImpersonatedUserId = impersonatedUserId;
            PathAndQueryParams = $"/{lobbyId}/tokens";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return ConstructBody(TokenRequest);
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json"
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "POST";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }

            if(!string.IsNullOrEmpty(ServiceId))
            {
                headers.Add("Service-id", ServiceId);
            }
            if(!string.IsNullOrEmpty(ImpersonatedUserId))
            {
                headers.Add("Impersonated-user-id", ImpersonatedUserId);
            }

            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// UpdateLobbyRequest
    /// Update lobby data
    /// </summary>
    [Preserve]
    internal class UpdateLobbyRequest : LobbyApiBaseRequest
    {
        /// <summary>Accessor for lobbyId </summary>
        [Preserve]
        public string LobbyId { get; }
        /// <summary>Accessor for serviceId </summary>
        [Preserve]
        public string ServiceId { get; }
        /// <summary>Accessor for impersonatedUserId </summary>
        [Preserve]
        public string ImpersonatedUserId { get; }
        /// <summary>Accessor for updateRequest </summary>
        [Preserve]
        public Unity.Services.Lobbies.Models.UpdateRequest UpdateRequest { get; }
        string PathAndQueryParams;

        /// <summary>
        /// UpdateLobby Request Object.
        /// Update lobby data
        /// </summary>
        /// <param name="lobbyId">The ID of the lobby to execute the request against. It should be composed of 64 characters or less, and only have dashes, underscores and alphanumeric characters.</param>
        /// <param name="serviceId">When service authentication is used, this provides a logical identity for the service</param>
        /// <param name="impersonatedUserId">When service authentication is used, this provides a 'playerId' to execute as. If this header is detected, the service request will be identical to a request from the specified player.</param>
        /// <param name="updateRequest">UpdateRequest param</param>
        [Preserve]
        public UpdateLobbyRequest(string lobbyId, string serviceId = default(string), string impersonatedUserId = default(string), Unity.Services.Lobbies.Models.UpdateRequest updateRequest = default(Unity.Services.Lobbies.Models.UpdateRequest))
        {
            LobbyId = lobbyId;

            ServiceId = serviceId;
            ImpersonatedUserId = impersonatedUserId;
            UpdateRequest = updateRequest;
            PathAndQueryParams = $"/{lobbyId}";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            if(UpdateRequest != null)
            {
                return ConstructBody(UpdateRequest);
            }
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json"
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "POST";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }

            if(!string.IsNullOrEmpty(ServiceId))
            {
                headers.Add("Service-id", ServiceId);
            }
            if(!string.IsNullOrEmpty(ImpersonatedUserId))
            {
                headers.Add("Impersonated-user-id", ImpersonatedUserId);
            }

            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// UpdatePlayerRequest
    /// Update player data
    /// </summary>
    [Preserve]
    internal class UpdatePlayerRequest : LobbyApiBaseRequest
    {
        /// <summary>Accessor for lobbyId </summary>
        [Preserve]
        public string LobbyId { get; }
        /// <summary>Accessor for playerId </summary>
        [Preserve]
        public string PlayerId { get; }
        /// <summary>Accessor for serviceId </summary>
        [Preserve]
        public string ServiceId { get; }
        /// <summary>Accessor for impersonatedUserId </summary>
        [Preserve]
        public string ImpersonatedUserId { get; }
        /// <summary>Accessor for playerUpdateRequest </summary>
        [Preserve]
        public Unity.Services.Lobbies.Models.PlayerUpdateRequest PlayerUpdateRequest { get; }
        string PathAndQueryParams;

        /// <summary>
        /// UpdatePlayer Request Object.
        /// Update player data
        /// </summary>
        /// <param name="lobbyId">The ID of the lobby to execute the request against. It should be composed of 64 characters or less, and only have dashes, underscores and alphanumeric characters.</param>
        /// <param name="playerId">The ID of the player to execute the request against.</param>
        /// <param name="serviceId">When service authentication is used, this provides a logical identity for the service</param>
        /// <param name="impersonatedUserId">When service authentication is used, this provides a 'playerId' to execute as. If this header is detected, the service request will be identical to a request from the specified player.</param>
        /// <param name="playerUpdateRequest">PlayerUpdateRequest param</param>
        [Preserve]
        public UpdatePlayerRequest(string lobbyId, string playerId, string serviceId = default(string), string impersonatedUserId = default(string), Unity.Services.Lobbies.Models.PlayerUpdateRequest playerUpdateRequest = default(Unity.Services.Lobbies.Models.PlayerUpdateRequest))
        {
            LobbyId = lobbyId;

            PlayerId = playerId;

            ServiceId = serviceId;
            ImpersonatedUserId = impersonatedUserId;
            PlayerUpdateRequest = playerUpdateRequest;
            PathAndQueryParams = $"/{lobbyId}/players/{playerId}";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            if(PlayerUpdateRequest != null)
            {
                return ConstructBody(PlayerUpdateRequest);
            }
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json"
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "POST";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }

            if(!string.IsNullOrEmpty(ServiceId))
            {
                headers.Add("Service-id", ServiceId);
            }
            if(!string.IsNullOrEmpty(ImpersonatedUserId))
            {
                headers.Add("Impersonated-user-id", ImpersonatedUserId);
            }

            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
}
